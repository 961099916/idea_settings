<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="814" />
    <option name="newTranslationDialogY" value="473" />
    <histories>
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning {@code true} upon success and throwing an {@code IllegalStateException} if no space is currently available." />
      <item value="Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to {@link add}, which can fail to insert an element only by throwing an exception." />
      <item value="The name of the properties to test. If a prefix has been defined, it is applied to compute the full key of each property. For instance if the prefix is {@code app.config} and one value is {@code my-value}, the full key would be {@code app.config.my-value} &lt;p&gt; Use the dashed notation to specify each property, that is all lower case with a &quot;-&quot; to separate words (e.g. {@code my-long-property}). @return the names" />
      <item value="watch delay,duration to pull new service from nacos server." />
      <item value="`" />
      <item value="Throw exceptions during service registration if true, otherwise, log error (defaults to true)." />
      <item value="If instance is ephemeral.The default value is true." />
      <item value="Quantity ERROR" />
      <item value="FINER indicates a fairly detailed tracing message. By default logging calls for entering, returning, or throwing an exception are traced at this level. This level is initialized to &lt;CODE&gt;400&lt;CODE&gt;." />
      <item value="INE messages might include things like minor (recoverable) failures. Issues indicating potential performance problems are also worth logging as FINE. This level is initialized to &lt;CODE&gt;500&lt;CODE&gt;." />
      <item value="All of FINE, FINER, and FINEST are intended for relatively detailed tracing. The exact meaning of the three levels will vary between subsystems, but in general, FINEST should be used for the most voluminous detailed output, FINER for somewhat less detailed output, and FINE for the lowest volume (and most important) messages." />
      <item value="FINE is a message level providing tracing information." />
      <item value="Creates and returns a copy of this object. The precise meaning of &quot;copy&quot; may depend on the class of the object. The general intent is that, for any object {@code x}, the expression: &lt;blockquote&gt; &lt;pre&gt; x.clone() != x&lt;pre&gt;&lt;blockquote&gt; will be true, and that the expression: &lt;blockquote&gt; &lt;pre&gt; x.clone().getClass() == x.getClass()&lt;pre&gt;&lt;blockquote&gt; will be {@code true}, but these are not absolute requirements. While it is typically the case that: &lt;blockquote&gt; &lt;pre&gt; x.clone().equals(x)&lt;pre&gt;&lt;blockquote&gt; will be {@code true}, this is not an absolute requirement. &lt;p&gt; By convention, the returned object should be obtained by calling {@code super.clone}. If a class and all of its superclasses (except {@code Object}) obey this convention, it will be the case that {@code x.clone().getClass() == x.getClass()}. &lt;p&gt; By convention, the object returned by this method should be independent of this object (which is being cloned). To achieve this independence, it may be necessary to modify one or more fields of the object returned by {@code super.clone} before returning it. Typically, this means copying any mutable objects that comprise the internal &quot;deep structure&quot; of the object being cloned and replacing the references to these objects with references to the copies. If a class contains only primitive fields or references to immutable objects, then it is usually the case that no fields in the object returned by {@code super.clone} need to be modified. &lt;p&gt; The method {@code clone} for class {@code Object} performs a specific cloning operation. First, if the class of this object does not implement the interface {@code Cloneable}, then a {@code CloneNotSupportedException} is thrown. Note that all arrays are considered to implement the interface {@code Cloneable} and that the return type of the {@code clone} method of an array type {@code T[]} is {@code T[]} where T is any reference or primitive type. Otherwise, this method creates a new instance of the class of this object and initializes all its fields with exactly the contents of the corresponding fields of this object, as if by assignment; the contents of the fields are not themselves cloned. Thus, this method performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation. &lt;p&gt; The class {@code Object} does not itself implement the interface {@code Cloneable}, so calling the {@code clone} method on an object whose class is {@code Object} will result in throwing an" />
      <item value="As far as is reasonably practical, the {@code hashCode} method defined by class {@code Object} returns distinct integers for distinct objects." />
      <item value="The {@code @HotSpotIntrinsicCandidate} annotation is specific to the HotSpot Virtual Machine. It indicates that an annotated method may be (but is not guaranteed to be) intrinsified by the HotSpot VM. A method is intrinsified if the HotSpot VM replaces the annotated method with hand-written assembly andor hand-written compiler IR -- a compiler intrinsic -- to improve performance. The {@code @HotSpotIntrinsicCandidate} annotation is internal to the Java libraries and is therefore not supposed to have any relevance for application code. Maintainers of the Java libraries must consider the following when modifying methods annotated with {@code @HotSpotIntrinsicCandidate}. &lt;ul&gt; &lt;li&gt;When modifying a method annotated with {@code @HotSpotIntrinsicCandidate}, the corresponding intrinsic code in the HotSpot VM implementation must be updated to match the semantics of the annotated method.&lt;li&gt; &lt;li&gt;For some annotated methods, the corresponding intrinsic may omit some low-level checks that would be performed as a matter of course if the intrinsic is implemented using Java bytecodes. This is because individual Java bytecodes implicitly check for exceptions like {@code NullPointerException} and {@code ArrayStoreException}. If such a method is replaced by an intrinsic coded in assembly language, any checks performed as a matter of normal bytecode operation must be performed before entry into the assembly code. These checks must be performed, as appropriate, on all arguments to the intrinsic, and on other values (if any) obtained by the intrinsic through those arguments. The checks may be deduced by inspecting the non-intrinsic Java code for the method, and determining exactly which exceptions may be thrown by the code, including undeclared implicit {@code RuntimeException}s. Therefore, depending on the data accesses performed by the intrinsic, the checks may include: &lt;ul&gt; &lt;li&gt;null checks on references&lt;li&gt; &lt;li&gt;range checks on primitive values used as array indexes&lt;li&gt; &lt;li&gt;other validity checks on primitive values (e.g., for divide-by-zero conditions)&lt;li&gt; &lt;li&gt;store checks on reference values stored into arrays&lt;li&gt; &lt;li&gt;array length checks on arrays indexed from within the intrinsic&lt;li&gt; &lt;li&gt;reference casts (when formal parameters are {@code Object} or some other weak type)&lt;li&gt; &lt;ul&gt; &lt;li&gt; &lt;li&gt;Note that the receiver value ({@code this}) is passed as a extra argument to all non-static methods. If a non-static method is an intrinsic, the receiver value does not need a null check, but (as stated above) any values loaded by the intrinsic from object fields must also be checked. As a matter of clarity, it is better to make intrinisics be static methods, to make the dependency on {@code this} clear. Also, it is better to explicitly load all required values from object fields before entering the intrinsic code, and pass those values as explicit arguments. First, this may be necessary for null checks (or other checks). Second, if the intrinsic reloads the values from fields and operates on those without checks, race conditions may be able to introduce unchecked invalid values into the intrinsic. If the intrinsic needs to store a value back to an object field, that value should be returned explicitly from the intrinsic; if there are multiple return values, coders should consider buffering them in an array. Removing field access from intrinsics not only clarifies the interface with between the JVM and JDK; it also helps decouple the HotSpot and JDK implementations, since if JDK code before and after the intrinsic manages all field accesses, then intrinsics can be coded to be agnostic of object layouts.&lt;li&gt; Maintainers of the HotSpot VM must consider the following when modifying intrinsics. &lt;ul&gt; &lt;li&gt;When adding a new intrinsic, make sure that the corresponding method in the Java libraries is annotated with {@code @HotSpotIntrinsicCandidate} and that all possible call sequences that result in calling the intrinsic contain the checks omitted by the intrinsic (if any).&lt;li&gt; &lt;li&gt;When modifying an existing intrinsic, the Java libraries must be updated to match the semantics of the intrinsic and to execute all checks omitted by the intrinsic (if any).&lt;li&gt; &lt;ul&gt; Persons not directly involved with maintaining the Java libraries or the HotSpot VM can safely ignore the fact that a method is annotated with {@code @HotSpotIntrinsicCandidate}. The HotSpot VM defines (internally) a list of intrinsics. Not all intrinsic are available on all platforms supported by the HotSpot VM. Furthermore, the availability of an intrinsic on a given platform depends on the configuration of the HotSpot VM (e.g., the set of VM flags enabled). Therefore, annotating a method with {@code @HotSpotIntrinsicCandidate} does not guarantee that the marked method is intrinsified by the HotSpot VM. If the {@code CheckIntrinsics} VM flag is enabled, the HotSpot VM checks (when loading a class) that (1) all methods of that class that are also on the VM's list of intrinsics are annotated with {@code @HotSpotIntrinsicCandidate} and that (2) for all methods of that class annotated with {@code @HotSpotIntrinsicCandidate} there is an intrinsic in the list." />
      <item value="corn" />
      <item value="purchaseOrderNo" />
      <item value="purchase Order No" />
      <item value="Rounding mode to round away from zero. Always increments the digit prior to a nonzero discarded fraction. Note that this rounding mode never decreases the magnitude of the calculated value." />
      <item value="Modify the application context's internal bean factory after its standard initialization. All bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for registering special BeanPostProcessors etc in certain ApplicationContext implementations." />
      <item value="configure the factory's standard context characteristics, such as the context's classloader and post-processors." />
      <item value="context" />
      <item value="Configure the factory's standard context characteristics, such as the context's ClassLoader and post-processors." />
      <item value="Do nothing: We hold a single internal BeanFactory and rely on callers to register beans through our public methods (or the BeanFactory's)." />
      <item value="Tell the subclass to refresh the internal bean factory." />
      <item value="REPLACE ANY STUB PROPERTY SOURCES WITH ACTUAL INSTANCES." />
      <item value="GET BY vehicle" />
      <item value="File" />
      <item value="Minimum idle Redis connection amount." />
      <item value="A basic, no operation {@link CacheManager} implementation suitable for disabling caching, typically used for backing cache declarations without an actual backing store. &lt;p&gt; Will simply accept any items into the cache not actually storing them." />
      <item value="depart Plan Number" />
      <item value="Composite {@link CacheManager} implementation that iterates over a given collection of delegate {@link CacheManager} instances. &lt;p&gt; Allows {@link NoOpCacheManager} to be automatically added to the end of the list for handling cache declarations without a backing store. Otherwise, any custom {@link CacheManager} may play that role of the last delegate as well, lazily creating cache regions for any requested name. &lt;p&gt; Note: Regular CacheManagers that this composite manager delegates to need to return {@code null} from {@link getCache(String)} if they are unaware of the specified cache name, allowing for iteration to the next delegate in line. However, most {@link CacheManager} implementations fall back to lazy creation of named caches once requested; check out the specific configuration details for a 'static' mode with fixed cache names, if available." />
      <item value="Convert the given value from the internal store to a user value returned from the get method (adapting" />
      <item value="Perform an actual lookup in the underlying store." />
      <item value="Dynamically register an additional Cache with this manager." />
      <item value="Update the exposed {@link cacheNames} set with the given name. &lt;p&gt; This will always be called within a full {@link cacheMap} lock and effectively behaves like a {@code CopyOnWriteArraySet} with preserved order but exposed as an unmodifiable reference. @param name the name of the cache to be added" />
      <item value="Returns an unmodifiable view of the specified set. Query operations on the returned set &quot;read through&quot; to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException." />
      <item value="Load the initial caches for this cache manager." />
      <item value="Interface to be implemented by beans that need to react once all their properties have been set by a {@link BeanFactory}: e.g. to perform custom initialization, or merely to check that all mandatory properties have been set. &lt;p&gt; An alternative to implementing {@code InitializingBean} is specifying a custom init method, for example in an XML bean definition. For a list of all bean lifecycle methods, see the {@link BeanFactory BeanFactory javadocs}." />
      <item value="Spring's central cache manager SPI" />
      <item value="Interface to be implemented by any @{@link Configuration} class that wishes to be injected with the {@link AnnotationMetadata} of the @{@code Configuration} class that imported it. Useful in conjunction with annotations that use @{@link Import} as a meta-annotation." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="39" />
        <entry key="ENGLISH" value="40" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1658132349183" />
  </component>
</application>